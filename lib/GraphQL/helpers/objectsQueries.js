"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.needToGetAllKeys = exports.calculateSkipAndLimit = exports.findObjects = exports.getObject = void 0;

var _node = _interopRequireDefault(require("parse/node"));

var _graphqlRelay = require("graphql-relay");

var _rest = _interopRequireDefault(require("../../rest"));

var _query = require("../transformers/query");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const needToGetAllKeys = (fields, keys) => keys ? !!keys.split(',').find(keyName => !fields[keyName.split('.')[0]]) : true;

exports.needToGetAllKeys = needToGetAllKeys;

const getObject = async (className, objectId, keys, include, readPreference, includeReadPreference, config, auth, info, parseClass) => {
  const options = {};

  if (!needToGetAllKeys(parseClass.fields, keys)) {
    options.keys = keys;
  }

  if (include) {
    options.include = include;

    if (includeReadPreference) {
      options.includeReadPreference = includeReadPreference;
    }
  }

  if (readPreference) {
    options.readPreference = readPreference;
  }

  const response = await _rest.default.get(config, auth, className, objectId, options, info.clientSDK);

  if (!response.results || response.results.length == 0) {
    throw new _node.default.Error(_node.default.Error.OBJECT_NOT_FOUND, 'Object not found.');
  }

  const object = response.results[0];

  if (className === '_User') {
    delete object.sessionToken;
  }

  return object;
};

exports.getObject = getObject;

const findObjects = async (className, where, order, skipInput, first, after, last, before, keys, include, includeAll, readPreference, includeReadPreference, subqueryReadPreference, config, auth, info, selectedFields, parseClasses) => {
  if (!where) {
    where = {};
  }

  (0, _query.transformQueryInputToParse)(where, className, parseClasses);
  const skipAndLimitCalculation = calculateSkipAndLimit(skipInput, first, after, last, before, config.maxLimit);
  let {
    skip
  } = skipAndLimitCalculation;
  const {
    limit,
    needToPreCount
  } = skipAndLimitCalculation;
  let preCount = undefined;

  if (needToPreCount) {
    const preCountOptions = {
      limit: 0,
      count: true
    };

    if (readPreference) {
      preCountOptions.readPreference = readPreference;
    }

    if (Object.keys(where).length > 0 && subqueryReadPreference) {
      preCountOptions.subqueryReadPreference = subqueryReadPreference;
    }

    preCount = (await _rest.default.find(config, auth, className, where, preCountOptions, info.clientSDK)).count;

    if ((skip || 0) + limit < preCount) {
      skip = preCount - limit;
    }
  }

  const options = {};

  if (selectedFields.find(field => field.startsWith('edges.') || field.startsWith('pageInfo.'))) {
    if (limit || limit === 0) {
      options.limit = limit;
    } else {
      options.limit = 100;
    }

    if (options.limit !== 0) {
      if (order) {
        options.order = order;
      }

      if (skip) {
        options.skip = skip;
      }

      if (config.maxLimit && options.limit > config.maxLimit) {
        // Silently replace the limit on the query with the max configured
        options.limit = config.maxLimit;
      }

      if (!needToGetAllKeys(parseClasses.find(({
        className: parseClassName
      }) => className === parseClassName).fields, keys)) {
        options.keys = keys;
      }

      if (includeAll === true) {
        options.includeAll = includeAll;
      }

      if (!options.includeAll && include) {
        options.include = include;
      }

      if ((options.includeAll || options.include) && includeReadPreference) {
        options.includeReadPreference = includeReadPreference;
      }
    }
  } else {
    options.limit = 0;
  }

  if ((selectedFields.includes('count') || selectedFields.includes('pageInfo.hasPreviousPage') || selectedFields.includes('pageInfo.hasNextPage')) && !needToPreCount) {
    options.count = true;
  }

  if (readPreference) {
    options.readPreference = readPreference;
  }

  if (Object.keys(where).length > 0 && subqueryReadPreference) {
    options.subqueryReadPreference = subqueryReadPreference;
  }

  let results, count;

  if (options.count || !options.limit || options.limit && options.limit > 0) {
    const findResult = await _rest.default.find(config, auth, className, where, options, info.clientSDK);
    results = findResult.results;
    count = findResult.count;
  }

  let edges = null;
  let pageInfo = null;

  if (results) {
    edges = results.map((result, index) => ({
      cursor: (0, _graphqlRelay.offsetToCursor)((skip || 0) + index),
      node: result
    }));
    pageInfo = {
      hasPreviousPage: (preCount && preCount > 0 || count && count > 0) && skip !== undefined && skip > 0,
      startCursor: (0, _graphqlRelay.offsetToCursor)(skip || 0),
      endCursor: (0, _graphqlRelay.offsetToCursor)((skip || 0) + (results.length || 1) - 1),
      hasNextPage: (preCount || count) > (skip || 0) + results.length
    };
  }

  return {
    edges,
    pageInfo,
    count: preCount || count
  };
};

exports.findObjects = findObjects;

const calculateSkipAndLimit = (skipInput, first, after, last, before, maxLimit) => {
  let skip = undefined;
  let limit = undefined;
  let needToPreCount = false; // Validates the skip input

  if (skipInput || skipInput === 0) {
    if (skipInput < 0) {
      throw new _node.default.Error(_node.default.Error.INVALID_QUERY, 'Skip should be a positive number');
    }

    skip = skipInput;
  } // Validates the after param


  if (after) {
    after = (0, _graphqlRelay.cursorToOffset)(after);

    if (!after && after !== 0 || after < 0) {
      throw new _node.default.Error(_node.default.Error.INVALID_QUERY, 'After is not a valid cursor');
    } // If skip and after are passed, a new skip is calculated by adding them


    skip = (skip || 0) + (after + 1);
  } // Validates the first param


  if (first || first === 0) {
    if (first < 0) {
      throw new _node.default.Error(_node.default.Error.INVALID_QUERY, 'First should be a positive number');
    } // The first param is translated to the limit param of the Parse legacy API


    limit = first;
  } // Validates the before param


  if (before || before === 0) {
    // This method converts the cursor to the index of the object
    before = (0, _graphqlRelay.cursorToOffset)(before);

    if (!before && before !== 0 || before < 0) {
      throw new _node.default.Error(_node.default.Error.INVALID_QUERY, 'Before is not a valid cursor');
    }

    if ((skip || 0) >= before) {
      // If the before index is less then the skip, no objects will be returned
      limit = 0;
    } else if (!limit && limit !== 0 || (skip || 0) + limit > before) {
      // If there is no limit set, the limit is calculated. Or, if the limit (plus skip) is bigger than the before index, the new limit is set.
      limit = before - (skip || 0);
    }
  } // Validates the last param


  if (last || last === 0) {
    if (last < 0) {
      throw new _node.default.Error(_node.default.Error.INVALID_QUERY, 'Last should be a positive number');
    }

    if (last > maxLimit) {
      // Last can't be bigger than Parse server maxLimit config.
      last = maxLimit;
    }

    if (limit || limit === 0) {
      // If there is a previous limit set, it may be adjusted
      if (last < limit) {
        // if last is less than the current limit
        skip = (skip || 0) + (limit - last); // The skip is adjusted

        limit = last; // the limit is adjusted
      }
    } else if (last === 0) {
      // No objects will be returned
      limit = 0;
    } else {
      // No previous limit set, the limit will be equal to last and pre count is needed.
      limit = last;
      needToPreCount = true;
    }
  }

  return {
    skip,
    limit,
    needToPreCount
  };
};

exports.calculateSkipAndLimit = calculateSkipAndLimit;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9HcmFwaFFML2hlbHBlcnMvb2JqZWN0c1F1ZXJpZXMuanMiXSwibmFtZXMiOlsibmVlZFRvR2V0QWxsS2V5cyIsImZpZWxkcyIsImtleXMiLCJzcGxpdCIsImZpbmQiLCJrZXlOYW1lIiwiZ2V0T2JqZWN0IiwiY2xhc3NOYW1lIiwib2JqZWN0SWQiLCJpbmNsdWRlIiwicmVhZFByZWZlcmVuY2UiLCJpbmNsdWRlUmVhZFByZWZlcmVuY2UiLCJjb25maWciLCJhdXRoIiwiaW5mbyIsInBhcnNlQ2xhc3MiLCJvcHRpb25zIiwicmVzcG9uc2UiLCJyZXN0IiwiZ2V0IiwiY2xpZW50U0RLIiwicmVzdWx0cyIsImxlbmd0aCIsIlBhcnNlIiwiRXJyb3IiLCJPQkpFQ1RfTk9UX0ZPVU5EIiwib2JqZWN0Iiwic2Vzc2lvblRva2VuIiwiZmluZE9iamVjdHMiLCJ3aGVyZSIsIm9yZGVyIiwic2tpcElucHV0IiwiZmlyc3QiLCJhZnRlciIsImxhc3QiLCJiZWZvcmUiLCJpbmNsdWRlQWxsIiwic3VicXVlcnlSZWFkUHJlZmVyZW5jZSIsInNlbGVjdGVkRmllbGRzIiwicGFyc2VDbGFzc2VzIiwic2tpcEFuZExpbWl0Q2FsY3VsYXRpb24iLCJjYWxjdWxhdGVTa2lwQW5kTGltaXQiLCJtYXhMaW1pdCIsInNraXAiLCJsaW1pdCIsIm5lZWRUb1ByZUNvdW50IiwicHJlQ291bnQiLCJ1bmRlZmluZWQiLCJwcmVDb3VudE9wdGlvbnMiLCJjb3VudCIsIk9iamVjdCIsImZpZWxkIiwic3RhcnRzV2l0aCIsInBhcnNlQ2xhc3NOYW1lIiwiaW5jbHVkZXMiLCJmaW5kUmVzdWx0IiwiZWRnZXMiLCJwYWdlSW5mbyIsIm1hcCIsInJlc3VsdCIsImluZGV4IiwiY3Vyc29yIiwibm9kZSIsImhhc1ByZXZpb3VzUGFnZSIsInN0YXJ0Q3Vyc29yIiwiZW5kQ3Vyc29yIiwiaGFzTmV4dFBhZ2UiLCJJTlZBTElEX1FVRVJZIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FB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QUFSO0FBQ0QsS0FITSxNQUdBO0FBQ0w7QUFDQUEsTUFBQUEsS0FBSyxHQUFHVixJQUFSO0FBQ0FXLE1BQUFBLGNBQWMsR0FBRyxJQUFqQjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTztBQUNMRixJQUFBQSxJQURLO0FBRUxDLElBQUFBLEtBRks7QUFHTEMsSUFBQUE7QUFISyxHQUFQO0FBS0QsQ0F6R0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGFyc2UgZnJvbSAncGFyc2Uvbm9kZSc7XG5pbXBvcnQgeyBvZmZzZXRUb0N1cnNvciwgY3Vyc29yVG9PZmZzZXQgfSBmcm9tICdncmFwaHFsLXJlbGF5JztcbmltcG9ydCByZXN0IGZyb20gJy4uLy4uL3Jlc3QnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUXVlcnlJbnB1dFRvUGFyc2UgfSBmcm9tICcuLi90cmFuc2Zvcm1lcnMvcXVlcnknO1xuXG5jb25zdCBuZWVkVG9HZXRBbGxLZXlzID0gKGZpZWxkcywga2V5cykgPT5cbiAga2V5c1xuICAgID8gISFrZXlzLnNwbGl0KCcsJykuZmluZChrZXlOYW1lID0+ICFmaWVsZHNba2V5TmFtZS5zcGxpdCgnLicpWzBdXSlcbiAgICA6IHRydWU7XG5cbmNvbnN0IGdldE9iamVjdCA9IGFzeW5jIChcbiAgY2xhc3NOYW1lLFxuICBvYmplY3RJZCxcbiAga2V5cyxcbiAgaW5jbHVkZSxcbiAgcmVhZFByZWZlcmVuY2UsXG4gIGluY2x1ZGVSZWFkUHJlZmVyZW5jZSxcbiAgY29uZmlnLFxuICBhdXRoLFxuICBpbmZvLFxuICBwYXJzZUNsYXNzXG4pID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICBpZiAoIW5lZWRUb0dldEFsbEtleXMocGFyc2VDbGFzcy5maWVsZHMsIGtleXMpKSB7XG4gICAgb3B0aW9ucy5rZXlzID0ga2V5cztcbiAgfVxuICBpZiAoaW5jbHVkZSkge1xuICAgIG9wdGlvbnMuaW5jbHVkZSA9IGluY2x1ZGU7XG4gICAgaWYgKGluY2x1ZGVSZWFkUHJlZmVyZW5jZSkge1xuICAgICAgb3B0aW9ucy5pbmNsdWRlUmVhZFByZWZlcmVuY2UgPSBpbmNsdWRlUmVhZFByZWZlcmVuY2U7XG4gICAgfVxuICB9XG4gIGlmIChyZWFkUHJlZmVyZW5jZSkge1xuICAgIG9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSByZWFkUHJlZmVyZW5jZTtcbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzdC5nZXQoXG4gICAgY29uZmlnLFxuICAgIGF1dGgsXG4gICAgY2xhc3NOYW1lLFxuICAgIG9iamVjdElkLFxuICAgIG9wdGlvbnMsXG4gICAgaW5mby5jbGllbnRTREtcbiAgKTtcblxuICBpZiAoIXJlc3BvbnNlLnJlc3VsdHMgfHwgcmVzcG9uc2UucmVzdWx0cy5sZW5ndGggPT0gMCkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELCAnT2JqZWN0IG5vdCBmb3VuZC4nKTtcbiAgfVxuXG4gIGNvbnN0IG9iamVjdCA9IHJlc3BvbnNlLnJlc3VsdHNbMF07XG4gIGlmIChjbGFzc05hbWUgPT09ICdfVXNlcicpIHtcbiAgICBkZWxldGUgb2JqZWN0LnNlc3Npb25Ub2tlbjtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgZmluZE9iamVjdHMgPSBhc3luYyAoXG4gIGNsYXNzTmFtZSxcbiAgd2hlcmUsXG4gIG9yZGVyLFxuICBza2lwSW5wdXQsXG4gIGZpcnN0LFxuICBhZnRlcixcbiAgbGFzdCxcbiAgYmVmb3JlLFxuICBrZXlzLFxuICBpbmNsdWRlLFxuICBpbmNsdWRlQWxsLFxuICByZWFkUHJlZmVyZW5jZSxcbiAgaW5jbHVkZVJlYWRQcmVmZXJlbmNlLFxuICBzdWJxdWVyeVJlYWRQcmVmZXJlbmNlLFxuICBjb25maWcsXG4gIGF1dGgsXG4gIGluZm8sXG4gIHNlbGVjdGVkRmllbGRzLFxuICBwYXJzZUNsYXNzZXNcbikgPT4ge1xuICBpZiAoIXdoZXJlKSB7XG4gICAgd2hlcmUgPSB7fTtcbiAgfVxuICB0cmFuc2Zvcm1RdWVyeUlucHV0VG9QYXJzZSh3aGVyZSwgY2xhc3NOYW1lLCBwYXJzZUNsYXNzZXMpO1xuICBjb25zdCBza2lwQW5kTGltaXRDYWxjdWxhdGlvbiA9IGNhbGN1bGF0ZVNraXBBbmRMaW1pdChcbiAgICBza2lwSW5wdXQsXG4gICAgZmlyc3QsXG4gICAgYWZ0ZXIsXG4gICAgbGFzdCxcbiAgICBiZWZvcmUsXG4gICAgY29uZmlnLm1heExpbWl0XG4gICk7XG4gIGxldCB7IHNraXAgfSA9IHNraXBBbmRMaW1pdENhbGN1bGF0aW9uO1xuICBjb25zdCB7IGxpbWl0LCBuZWVkVG9QcmVDb3VudCB9ID0gc2tpcEFuZExpbWl0Q2FsY3VsYXRpb247XG4gIGxldCBwcmVDb3VudCA9IHVuZGVmaW5lZDtcbiAgaWYgKG5lZWRUb1ByZUNvdW50KSB7XG4gICAgY29uc3QgcHJlQ291bnRPcHRpb25zID0ge1xuICAgICAgbGltaXQ6IDAsXG4gICAgICBjb3VudDogdHJ1ZSxcbiAgICB9O1xuICAgIGlmIChyZWFkUHJlZmVyZW5jZSkge1xuICAgICAgcHJlQ291bnRPcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gcmVhZFByZWZlcmVuY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh3aGVyZSkubGVuZ3RoID4gMCAmJiBzdWJxdWVyeVJlYWRQcmVmZXJlbmNlKSB7XG4gICAgICBwcmVDb3VudE9wdGlvbnMuc3VicXVlcnlSZWFkUHJlZmVyZW5jZSA9IHN1YnF1ZXJ5UmVhZFByZWZlcmVuY2U7XG4gICAgfVxuICAgIHByZUNvdW50ID0gKFxuICAgICAgYXdhaXQgcmVzdC5maW5kKFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGF1dGgsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIHByZUNvdW50T3B0aW9ucyxcbiAgICAgICAgaW5mby5jbGllbnRTREtcbiAgICAgIClcbiAgICApLmNvdW50O1xuICAgIGlmICgoc2tpcCB8fCAwKSArIGxpbWl0IDwgcHJlQ291bnQpIHtcbiAgICAgIHNraXAgPSBwcmVDb3VudCAtIGxpbWl0O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICBpZiAoXG4gICAgc2VsZWN0ZWRGaWVsZHMuZmluZChcbiAgICAgIGZpZWxkID0+IGZpZWxkLnN0YXJ0c1dpdGgoJ2VkZ2VzLicpIHx8IGZpZWxkLnN0YXJ0c1dpdGgoJ3BhZ2VJbmZvLicpXG4gICAgKVxuICApIHtcbiAgICBpZiAobGltaXQgfHwgbGltaXQgPT09IDApIHtcbiAgICAgIG9wdGlvbnMubGltaXQgPSBsaW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5saW1pdCA9IDEwMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQgIT09IDApIHtcbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICBvcHRpb25zLm9yZGVyID0gb3JkZXI7XG4gICAgICB9XG4gICAgICBpZiAoc2tpcCkge1xuICAgICAgICBvcHRpb25zLnNraXAgPSBza2lwO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5tYXhMaW1pdCAmJiBvcHRpb25zLmxpbWl0ID4gY29uZmlnLm1heExpbWl0KSB7XG4gICAgICAgIC8vIFNpbGVudGx5IHJlcGxhY2UgdGhlIGxpbWl0IG9uIHRoZSBxdWVyeSB3aXRoIHRoZSBtYXggY29uZmlndXJlZFxuICAgICAgICBvcHRpb25zLmxpbWl0ID0gY29uZmlnLm1heExpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAhbmVlZFRvR2V0QWxsS2V5cyhcbiAgICAgICAgICBwYXJzZUNsYXNzZXMuZmluZChcbiAgICAgICAgICAgICh7IGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWUgfSkgPT4gY2xhc3NOYW1lID09PSBwYXJzZUNsYXNzTmFtZVxuICAgICAgICAgICkuZmllbGRzLFxuICAgICAgICAgIGtleXNcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIG9wdGlvbnMua2V5cyA9IGtleXM7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZUFsbCA9PT0gdHJ1ZSkge1xuICAgICAgICBvcHRpb25zLmluY2x1ZGVBbGwgPSBpbmNsdWRlQWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLmluY2x1ZGVBbGwgJiYgaW5jbHVkZSkge1xuICAgICAgICBvcHRpb25zLmluY2x1ZGUgPSBpbmNsdWRlO1xuICAgICAgfVxuICAgICAgaWYgKChvcHRpb25zLmluY2x1ZGVBbGwgfHwgb3B0aW9ucy5pbmNsdWRlKSAmJiBpbmNsdWRlUmVhZFByZWZlcmVuY2UpIHtcbiAgICAgICAgb3B0aW9ucy5pbmNsdWRlUmVhZFByZWZlcmVuY2UgPSBpbmNsdWRlUmVhZFByZWZlcmVuY2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMubGltaXQgPSAwO1xuICB9XG5cbiAgaWYgKFxuICAgIChzZWxlY3RlZEZpZWxkcy5pbmNsdWRlcygnY291bnQnKSB8fFxuICAgICAgc2VsZWN0ZWRGaWVsZHMuaW5jbHVkZXMoJ3BhZ2VJbmZvLmhhc1ByZXZpb3VzUGFnZScpIHx8XG4gICAgICBzZWxlY3RlZEZpZWxkcy5pbmNsdWRlcygncGFnZUluZm8uaGFzTmV4dFBhZ2UnKSkgJiZcbiAgICAhbmVlZFRvUHJlQ291bnRcbiAgKSB7XG4gICAgb3B0aW9ucy5jb3VudCA9IHRydWU7XG4gIH1cblxuICBpZiAocmVhZFByZWZlcmVuY2UpIHtcbiAgICBvcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gcmVhZFByZWZlcmVuY2U7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGggPiAwICYmIHN1YnF1ZXJ5UmVhZFByZWZlcmVuY2UpIHtcbiAgICBvcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2UgPSBzdWJxdWVyeVJlYWRQcmVmZXJlbmNlO1xuICB9XG5cbiAgbGV0IHJlc3VsdHMsIGNvdW50O1xuICBpZiAob3B0aW9ucy5jb3VudCB8fCAhb3B0aW9ucy5saW1pdCB8fCAob3B0aW9ucy5saW1pdCAmJiBvcHRpb25zLmxpbWl0ID4gMCkpIHtcbiAgICBjb25zdCBmaW5kUmVzdWx0ID0gYXdhaXQgcmVzdC5maW5kKFxuICAgICAgY29uZmlnLFxuICAgICAgYXV0aCxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHdoZXJlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGluZm8uY2xpZW50U0RLXG4gICAgKTtcbiAgICByZXN1bHRzID0gZmluZFJlc3VsdC5yZXN1bHRzO1xuICAgIGNvdW50ID0gZmluZFJlc3VsdC5jb3VudDtcbiAgfVxuXG4gIGxldCBlZGdlcyA9IG51bGw7XG4gIGxldCBwYWdlSW5mbyA9IG51bGw7XG4gIGlmIChyZXN1bHRzKSB7XG4gICAgZWRnZXMgPSByZXN1bHRzLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gKHtcbiAgICAgIGN1cnNvcjogb2Zmc2V0VG9DdXJzb3IoKHNraXAgfHwgMCkgKyBpbmRleCksXG4gICAgICBub2RlOiByZXN1bHQsXG4gICAgfSkpO1xuXG4gICAgcGFnZUluZm8gPSB7XG4gICAgICBoYXNQcmV2aW91c1BhZ2U6XG4gICAgICAgICgocHJlQ291bnQgJiYgcHJlQ291bnQgPiAwKSB8fCAoY291bnQgJiYgY291bnQgPiAwKSkgJiZcbiAgICAgICAgc2tpcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHNraXAgPiAwLFxuICAgICAgc3RhcnRDdXJzb3I6IG9mZnNldFRvQ3Vyc29yKHNraXAgfHwgMCksXG4gICAgICBlbmRDdXJzb3I6IG9mZnNldFRvQ3Vyc29yKChza2lwIHx8IDApICsgKHJlc3VsdHMubGVuZ3RoIHx8IDEpIC0gMSksXG4gICAgICBoYXNOZXh0UGFnZTogKHByZUNvdW50IHx8IGNvdW50KSA+IChza2lwIHx8IDApICsgcmVzdWx0cy5sZW5ndGgsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZWRnZXMsXG4gICAgcGFnZUluZm8sXG4gICAgY291bnQ6IHByZUNvdW50IHx8IGNvdW50LFxuICB9O1xufTtcblxuY29uc3QgY2FsY3VsYXRlU2tpcEFuZExpbWl0ID0gKFxuICBza2lwSW5wdXQsXG4gIGZpcnN0LFxuICBhZnRlcixcbiAgbGFzdCxcbiAgYmVmb3JlLFxuICBtYXhMaW1pdFxuKSA9PiB7XG4gIGxldCBza2lwID0gdW5kZWZpbmVkO1xuICBsZXQgbGltaXQgPSB1bmRlZmluZWQ7XG4gIGxldCBuZWVkVG9QcmVDb3VudCA9IGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlcyB0aGUgc2tpcCBpbnB1dFxuICBpZiAoc2tpcElucHV0IHx8IHNraXBJbnB1dCA9PT0gMCkge1xuICAgIGlmIChza2lwSW5wdXQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLklOVkFMSURfUVVFUlksXG4gICAgICAgICdTa2lwIHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICk7XG4gICAgfVxuICAgIHNraXAgPSBza2lwSW5wdXQ7XG4gIH1cblxuICAvLyBWYWxpZGF0ZXMgdGhlIGFmdGVyIHBhcmFtXG4gIGlmIChhZnRlcikge1xuICAgIGFmdGVyID0gY3Vyc29yVG9PZmZzZXQoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyICYmIGFmdGVyICE9PSAwKSB8fCBhZnRlciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9RVUVSWSxcbiAgICAgICAgJ0FmdGVyIGlzIG5vdCBhIHZhbGlkIGN1cnNvcidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSWYgc2tpcCBhbmQgYWZ0ZXIgYXJlIHBhc3NlZCwgYSBuZXcgc2tpcCBpcyBjYWxjdWxhdGVkIGJ5IGFkZGluZyB0aGVtXG4gICAgc2tpcCA9IChza2lwIHx8IDApICsgKGFmdGVyICsgMSk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZXMgdGhlIGZpcnN0IHBhcmFtXG4gIGlmIChmaXJzdCB8fCBmaXJzdCA9PT0gMCkge1xuICAgIGlmIChmaXJzdCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9RVUVSWSxcbiAgICAgICAgJ0ZpcnN0IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZpcnN0IHBhcmFtIGlzIHRyYW5zbGF0ZWQgdG8gdGhlIGxpbWl0IHBhcmFtIG9mIHRoZSBQYXJzZSBsZWdhY3kgQVBJXG4gICAgbGltaXQgPSBmaXJzdDtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlcyB0aGUgYmVmb3JlIHBhcmFtXG4gIGlmIChiZWZvcmUgfHwgYmVmb3JlID09PSAwKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgY29udmVydHMgdGhlIGN1cnNvciB0byB0aGUgaW5kZXggb2YgdGhlIG9iamVjdFxuICAgIGJlZm9yZSA9IGN1cnNvclRvT2Zmc2V0KGJlZm9yZSk7XG4gICAgaWYgKCghYmVmb3JlICYmIGJlZm9yZSAhPT0gMCkgfHwgYmVmb3JlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgICBQYXJzZS5FcnJvci5JTlZBTElEX1FVRVJZLFxuICAgICAgICAnQmVmb3JlIGlzIG5vdCBhIHZhbGlkIGN1cnNvcidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKChza2lwIHx8IDApID49IGJlZm9yZSkge1xuICAgICAgLy8gSWYgdGhlIGJlZm9yZSBpbmRleCBpcyBsZXNzIHRoZW4gdGhlIHNraXAsIG5vIG9iamVjdHMgd2lsbCBiZSByZXR1cm5lZFxuICAgICAgbGltaXQgPSAwO1xuICAgIH0gZWxzZSBpZiAoKCFsaW1pdCAmJiBsaW1pdCAhPT0gMCkgfHwgKHNraXAgfHwgMCkgKyBsaW1pdCA+IGJlZm9yZSkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbGltaXQgc2V0LCB0aGUgbGltaXQgaXMgY2FsY3VsYXRlZC4gT3IsIGlmIHRoZSBsaW1pdCAocGx1cyBza2lwKSBpcyBiaWdnZXIgdGhhbiB0aGUgYmVmb3JlIGluZGV4LCB0aGUgbmV3IGxpbWl0IGlzIHNldC5cbiAgICAgIGxpbWl0ID0gYmVmb3JlIC0gKHNraXAgfHwgMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVmFsaWRhdGVzIHRoZSBsYXN0IHBhcmFtXG4gIGlmIChsYXN0IHx8IGxhc3QgPT09IDApIHtcbiAgICBpZiAobGFzdCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9RVUVSWSxcbiAgICAgICAgJ0xhc3Qgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCA+IG1heExpbWl0KSB7XG4gICAgICAvLyBMYXN0IGNhbid0IGJlIGJpZ2dlciB0aGFuIFBhcnNlIHNlcnZlciBtYXhMaW1pdCBjb25maWcuXG4gICAgICBsYXN0ID0gbWF4TGltaXQ7XG4gICAgfVxuXG4gICAgaWYgKGxpbWl0IHx8IGxpbWl0ID09PSAwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHByZXZpb3VzIGxpbWl0IHNldCwgaXQgbWF5IGJlIGFkanVzdGVkXG4gICAgICBpZiAobGFzdCA8IGxpbWl0KSB7XG4gICAgICAgIC8vIGlmIGxhc3QgaXMgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGxpbWl0XG4gICAgICAgIHNraXAgPSAoc2tpcCB8fCAwKSArIChsaW1pdCAtIGxhc3QpOyAvLyBUaGUgc2tpcCBpcyBhZGp1c3RlZFxuICAgICAgICBsaW1pdCA9IGxhc3Q7IC8vIHRoZSBsaW1pdCBpcyBhZGp1c3RlZFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gMCkge1xuICAgICAgLy8gTm8gb2JqZWN0cyB3aWxsIGJlIHJldHVybmVkXG4gICAgICBsaW1pdCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIHByZXZpb3VzIGxpbWl0IHNldCwgdGhlIGxpbWl0IHdpbGwgYmUgZXF1YWwgdG8gbGFzdCBhbmQgcHJlIGNvdW50IGlzIG5lZWRlZC5cbiAgICAgIGxpbWl0ID0gbGFzdDtcbiAgICAgIG5lZWRUb1ByZUNvdW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBza2lwLFxuICAgIGxpbWl0LFxuICAgIG5lZWRUb1ByZUNvdW50LFxuICB9O1xufTtcblxuZXhwb3J0IHsgZ2V0T2JqZWN0LCBmaW5kT2JqZWN0cywgY2FsY3VsYXRlU2tpcEFuZExpbWl0LCBuZWVkVG9HZXRBbGxLZXlzIH07XG4iXX0=