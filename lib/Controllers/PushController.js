"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.PushController = void 0;

var _node = require("parse/node");

var _RestQuery = _interopRequireDefault(require("../RestQuery"));

var _RestWrite = _interopRequireDefault(require("../RestWrite"));

var _Auth = require("../Auth");

var _StatusHandler = require("../StatusHandler");

var _utils = require("../Push/utils");

var _logger = require("../logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PushController {
  sendPush(body = {}, where = {}, config, auth, onPushStatusSaved = () => {}, now = new Date()) {
    if (!config.hasPushSupport) {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Missing push configuration');
    } // Replace the expiration_time and push_time with a valid Unix epoch milliseconds time


    body.expiration_time = PushController.getExpirationTime(body);
    body.expiration_interval = PushController.getExpirationInterval(body);

    if (body.expiration_time && body.expiration_interval) {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, 'Both expiration_time and expiration_interval cannot be set');
    } // Immediate push


    if (body.expiration_interval && !Object.prototype.hasOwnProperty.call(body, 'push_time')) {
      const ttlMs = body.expiration_interval * 1000;
      body.expiration_time = new Date(now.valueOf() + ttlMs).valueOf();
    }

    const pushTime = PushController.getPushTime(body);

    if (pushTime && pushTime.date !== 'undefined') {
      body['push_time'] = PushController.formatPushTime(pushTime);
    } // TODO: If the req can pass the checking, we return immediately instead of waiting
    // pushes to be sent. We probably change this behaviour in the future.


    let badgeUpdate = () => {
      return Promise.resolve();
    };

    if (body.data && body.data.badge) {
      const badge = body.data.badge;
      let restUpdate = {};

      if (typeof badge == 'string' && badge.toLowerCase() === 'increment') {
        restUpdate = {
          badge: {
            __op: 'Increment',
            amount: 1
          }
        };
      } else if (typeof badge == 'object' && typeof badge.__op == 'string' && badge.__op.toLowerCase() == 'increment' && Number(badge.amount)) {
        restUpdate = {
          badge: {
            __op: 'Increment',
            amount: badge.amount
          }
        };
      } else if (Number(badge)) {
        restUpdate = {
          badge: badge
        };
      } else {
        throw "Invalid value for badge, expected number or 'Increment' or {increment: number}";
      } // Force filtering on only valid device tokens


      const updateWhere = (0, _utils.applyDeviceTokenExists)(where);

      badgeUpdate = () => {
        // Build a real RestQuery so we can use it in RestWrite
        const restQuery = new _RestQuery.default(config, (0, _Auth.master)(config), '_Installation', updateWhere);
        return restQuery.buildRestWhere().then(() => {
          const write = new _RestWrite.default(config, (0, _Auth.master)(config), '_Installation', restQuery.restWhere, restUpdate);
          write.runOptions.many = true;
          return write.execute();
        });
      };
    }

    const pushStatus = (0, _StatusHandler.pushStatusHandler)(config);
    return Promise.resolve().then(() => {
      return pushStatus.setInitial(body, where);
    }).then(() => {
      onPushStatusSaved(pushStatus.objectId);
      return badgeUpdate().catch(err => {
        // add this to ignore badge update errors as default
        if (config.stopOnBadgeUpdateError) throw err;

        _logger.logger.info(`Badge update error will be ignored for push status ${pushStatus.objectId}`);

        _logger.logger.info(err && err.stack && err.stack.toString() || err && err.message || err.toString());

        return Promise.resolve();
      });
    }).then(() => {
      // Update audience lastUsed and timesUsed
      if (body.audience_id) {
        const audienceId = body.audience_id;
        var updateAudience = {
          lastUsed: {
            __type: 'Date',
            iso: new Date().toISOString()
          },
          timesUsed: {
            __op: 'Increment',
            amount: 1
          }
        };
        const write = new _RestWrite.default(config, (0, _Auth.master)(config), '_Audience', {
          objectId: audienceId
        }, updateAudience);
        write.execute();
      } // Don't wait for the audience update promise to resolve.


      return Promise.resolve();
    }).then(() => {
      if (Object.prototype.hasOwnProperty.call(body, 'push_time') && config.hasPushScheduledSupport) {
        return Promise.resolve();
      }

      return config.pushControllerQueue.enqueue(body, where, config, auth, pushStatus);
    }).catch(err => {
      return pushStatus.fail(err).then(() => {
        throw err;
      });
    });
  }
  /**
   * Get expiration time from the request body.
   * @param {Object} request A request object
   * @returns {Number|undefined} The expiration time if it exists in the request
   */


  static getExpirationTime(body = {}) {
    var hasExpirationTime = Object.prototype.hasOwnProperty.call(body, 'expiration_time');

    if (!hasExpirationTime) {
      return;
    }

    var expirationTimeParam = body['expiration_time'];
    var expirationTime;

    if (typeof expirationTimeParam === 'number') {
      expirationTime = new Date(expirationTimeParam * 1000);
    } else if (typeof expirationTimeParam === 'string') {
      expirationTime = new Date(expirationTimeParam);
    } else {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, body['expiration_time'] + ' is not valid time.');
    } // Check expirationTime is valid or not, if it is not valid, expirationTime is NaN


    if (!isFinite(expirationTime)) {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, body['expiration_time'] + ' is not valid time.');
    }

    return expirationTime.valueOf();
  }

  static getExpirationInterval(body = {}) {
    const hasExpirationInterval = Object.prototype.hasOwnProperty.call(body, 'expiration_interval');

    if (!hasExpirationInterval) {
      return;
    }

    var expirationIntervalParam = body['expiration_interval'];

    if (typeof expirationIntervalParam !== 'number' || expirationIntervalParam <= 0) {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, `expiration_interval must be a number greater than 0`);
    }

    return expirationIntervalParam;
  }
  /**
   * Get push time from the request body.
   * @param {Object} request A request object
   * @returns {Number|undefined} The push time if it exists in the request
   */


  static getPushTime(body = {}) {
    var hasPushTime = Object.prototype.hasOwnProperty.call(body, 'push_time');

    if (!hasPushTime) {
      return;
    }

    var pushTimeParam = body['push_time'];
    var date;
    var isLocalTime = true;

    if (typeof pushTimeParam === 'number') {
      date = new Date(pushTimeParam * 1000);
    } else if (typeof pushTimeParam === 'string') {
      isLocalTime = !PushController.pushTimeHasTimezoneComponent(pushTimeParam);
      date = new Date(pushTimeParam);
    } else {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, body['push_time'] + ' is not valid time.');
    } // Check pushTime is valid or not, if it is not valid, pushTime is NaN


    if (!isFinite(date)) {
      throw new _node.Parse.Error(_node.Parse.Error.PUSH_MISCONFIGURED, body['push_time'] + ' is not valid time.');
    }

    return {
      date,
      isLocalTime
    };
  }
  /**
   * Checks if a ISO8601 formatted date contains a timezone component
   * @param pushTimeParam {string}
   * @returns {boolean}
   */


  static pushTimeHasTimezoneComponent(pushTimeParam) {
    const offsetPattern = /(.+)([+-])\d\d:\d\d$/;
    return pushTimeParam.indexOf('Z') === pushTimeParam.length - 1 || // 2007-04-05T12:30Z
    offsetPattern.test(pushTimeParam); // 2007-04-05T12:30.000+02:00, 2007-04-05T12:30.000-02:00
  }
  /**
   * Converts a date to ISO format in UTC time and strips the timezone if `isLocalTime` is true
   * @param date {Date}
   * @param isLocalTime {boolean}
   * @returns {string}
   */


  static formatPushTime({
    date,
    isLocalTime
  }) {
    if (isLocalTime) {
      // Strip 'Z'
      const isoString = date.toISOString();
      return isoString.substring(0, isoString.indexOf('Z'));
    }

    return date.toISOString();
  }

}

exports.PushController = PushController;
var _default = PushController;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Db250cm9sbGVycy9QdXNoQ29udHJvbGxlci5qcyJdLCJuYW1lcyI6WyJQdXNoQ29udHJvbGxlciIsInNlbmRQdXNoIiwiYm9keSIsIndoZXJlIiwiY29uZmlnIiwiYXV0aCIsIm9uUHVzaFN0YXR1c1NhdmVkIiwibm93IiwiRGF0ZSIsImhhc1B1c2hTdXBwb3J0IiwiUGFyc2UiLCJFcnJvciIsIlBVU0hfTUlTQ09ORklHVVJFRCIsImV4cGlyYXRpb25fdGltZSIsImdldEV4cGlyYXRpb25UaW1lIiwiZXhwaXJhdGlvbl9pbnRlcnZhbCIsImdldEV4cGlyYXRpb25JbnRlcnZhbCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInR0bE1zIiwidmFsdWVPZiIsInB1c2hUaW1lIiwiZ2V0UHVzaFRpbWUiLCJkYXRlIiwiZm9ybWF0UHVzaFRpbWUiLCJiYWRnZVVwZGF0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZGF0YSIsImJhZGdlIiwicmVzdFVwZGF0ZSIsInRvTG93ZXJDYXNlIiwiX19vcCIsImFtb3VudCIsIk51bWJlciIsInVwZGF0ZVdoZXJlIiwicmVzdFF1ZXJ5IiwiUmVzdFF1ZXJ5IiwiYnVpbGRSZXN0V2hlcmUiLCJ0aGVuIiwid3JpdGUiLCJSZXN0V3JpdGUiLCJyZXN0V2hlcmUiLCJydW5PcHRpb25zIiwibWFueSIsImV4ZWN1dGUiLCJwdXNoU3RhdHVzIiwic2V0SW5pdGlhbCIsIm9iamVjdElkIiwiY2F0Y2giLCJlcnIiLCJzdG9wT25CYWRnZVVwZGF0ZUVycm9yIiwibG9nZ2VyIiwiaW5mbyIsInN0YWNrIiwidG9TdHJpbmciLCJtZXNzYWdlIiwiYXVkaWVuY2VfaWQiLCJhdWRpZW5jZUlkIiwidXBkYXRlQXVkaWVuY2UiLCJsYXN0VXNlZCIsIl9fdHlwZSIsImlzbyIsInRvSVNPU3RyaW5nIiwidGltZXNVc2VkIiwiaGFzUHVzaFNjaGVkdWxlZFN1cHBvcnQiLCJwdXNoQ29udHJvbGxlclF1ZXVlIiwiZW5xdWV1ZSIsImZhaWwiLCJoYXNFeHBpcmF0aW9uVGltZSIsImV4cGlyYXRpb25UaW1lUGFyYW0iLCJleHBpcmF0aW9uVGltZSIsImlzRmluaXRlIiwiaGFzRXhwaXJhdGlvbkludGVydmFsIiwiZXhwaXJhdGlvbkludGVydmFsUGFyYW0iLCJoYXNQdXNoVGltZSIsInB1c2hUaW1lUGFyYW0iLCJpc0xvY2FsVGltZSIsInB1c2hUaW1lSGFzVGltZXpvbmVDb21wb25lbnQiLCJvZmZzZXRQYXR0ZXJuIiwiaW5kZXhPZiIsImxlbmd0aCIsInRlc3QiLCJpc29TdHJpbmciLCJzdWJzdHJpbmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVPLE1BQU1BLGNBQU4sQ0FBcUI7QUFDMUJDLEVBQUFBLFFBQVEsQ0FDTkMsSUFBSSxHQUFHLEVBREQsRUFFTkMsS0FBSyxHQUFHLEVBRkYsRUFHTkMsTUFITSxFQUlOQyxJQUpNLEVBS05DLGlCQUFpQixHQUFHLE1BQU0sQ0FBRSxDQUx0QixFQU1OQyxHQUFHLEdBQUcsSUFBSUMsSUFBSixFQU5BLEVBT047QUFDQSxRQUFJLENBQUNKLE1BQU0sQ0FBQ0ssY0FBWixFQUE0QjtBQUMxQixZQUFNLElBQUlDLFlBQU1DLEtBQVYsQ0FDSkQsWUFBTUMsS0FBTixDQUFZQyxrQkFEUixFQUVKLDRCQUZJLENBQU47QUFJRCxLQU5ELENBUUE7OztBQUNBVixJQUFBQSxJQUFJLENBQUNXLGVBQUwsR0FBdUJiLGNBQWMsQ0FBQ2MsaUJBQWYsQ0FBaUNaLElBQWpDLENBQXZCO0FBQ0FBLElBQUFBLElBQUksQ0FBQ2EsbUJBQUwsR0FBMkJmLGNBQWMsQ0FBQ2dCLHFCQUFmLENBQXFDZCxJQUFyQyxDQUEzQjs7QUFDQSxRQUFJQSxJQUFJLENBQUNXLGVBQUwsSUFBd0JYLElBQUksQ0FBQ2EsbUJBQWpDLEVBQXNEO0FBQ3BELFlBQU0sSUFBSUwsWUFBTUMsS0FBVixDQUNKRCxZQUFNQyxLQUFOLENBQVlDLGtCQURSLEVBRUosNERBRkksQ0FBTjtBQUlELEtBaEJELENBa0JBOzs7QUFDQSxRQUNFVixJQUFJLENBQUNhLG1CQUFMLElBQ0EsQ0FBQ0UsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNsQixJQUFyQyxFQUEyQyxXQUEzQyxDQUZILEVBR0U7QUFDQSxZQUFNbUIsS0FBSyxHQUFHbkIsSUFBSSxDQUFDYSxtQkFBTCxHQUEyQixJQUF6QztBQUNBYixNQUFBQSxJQUFJLENBQUNXLGVBQUwsR0FBdUIsSUFBSUwsSUFBSixDQUFTRCxHQUFHLENBQUNlLE9BQUosS0FBZ0JELEtBQXpCLEVBQWdDQyxPQUFoQyxFQUF2QjtBQUNEOztBQUVELFVBQU1DLFFBQVEsR0FBR3ZCLGNBQWMsQ0FBQ3dCLFdBQWYsQ0FBMkJ0QixJQUEzQixDQUFqQjs7QUFDQSxRQUFJcUIsUUFBUSxJQUFJQSxRQUFRLENBQUNFLElBQVQsS0FBa0IsV0FBbEMsRUFBK0M7QUFDN0N2QixNQUFBQSxJQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CRixjQUFjLENBQUMwQixjQUFmLENBQThCSCxRQUE5QixDQUFwQjtBQUNELEtBOUJELENBZ0NBO0FBQ0E7OztBQUNBLFFBQUlJLFdBQVcsR0FBRyxNQUFNO0FBQ3RCLGFBQU9DLE9BQU8sQ0FBQ0MsT0FBUixFQUFQO0FBQ0QsS0FGRDs7QUFJQSxRQUFJM0IsSUFBSSxDQUFDNEIsSUFBTCxJQUFhNUIsSUFBSSxDQUFDNEIsSUFBTCxDQUFVQyxLQUEzQixFQUFrQztBQUNoQyxZQUFNQSxLQUFLLEdBQUc3QixJQUFJLENBQUM0QixJQUFMLENBQVVDLEtBQXhCO0FBQ0EsVUFBSUMsVUFBVSxHQUFHLEVBQWpCOztBQUNBLFVBQUksT0FBT0QsS0FBUCxJQUFnQixRQUFoQixJQUE0QkEsS0FBSyxDQUFDRSxXQUFOLE9BQXdCLFdBQXhELEVBQXFFO0FBQ25FRCxRQUFBQSxVQUFVLEdBQUc7QUFBRUQsVUFBQUEsS0FBSyxFQUFFO0FBQUVHLFlBQUFBLElBQUksRUFBRSxXQUFSO0FBQXFCQyxZQUFBQSxNQUFNLEVBQUU7QUFBN0I7QUFBVCxTQUFiO0FBQ0QsT0FGRCxNQUVPLElBQ0wsT0FBT0osS0FBUCxJQUFnQixRQUFoQixJQUNBLE9BQU9BLEtBQUssQ0FBQ0csSUFBYixJQUFxQixRQURyQixJQUVBSCxLQUFLLENBQUNHLElBQU4sQ0FBV0QsV0FBWCxNQUE0QixXQUY1QixJQUdBRyxNQUFNLENBQUNMLEtBQUssQ0FBQ0ksTUFBUCxDQUpELEVBS0w7QUFDQUgsUUFBQUEsVUFBVSxHQUFHO0FBQUVELFVBQUFBLEtBQUssRUFBRTtBQUFFRyxZQUFBQSxJQUFJLEVBQUUsV0FBUjtBQUFxQkMsWUFBQUEsTUFBTSxFQUFFSixLQUFLLENBQUNJO0FBQW5DO0FBQVQsU0FBYjtBQUNELE9BUE0sTUFPQSxJQUFJQyxNQUFNLENBQUNMLEtBQUQsQ0FBVixFQUFtQjtBQUN4QkMsUUFBQUEsVUFBVSxHQUFHO0FBQUVELFVBQUFBLEtBQUssRUFBRUE7QUFBVCxTQUFiO0FBQ0QsT0FGTSxNQUVBO0FBQ0wsY0FBTSxnRkFBTjtBQUNELE9BaEIrQixDQWtCaEM7OztBQUNBLFlBQU1NLFdBQVcsR0FBRyxtQ0FBdUJsQyxLQUF2QixDQUFwQjs7QUFDQXdCLE1BQUFBLFdBQVcsR0FBRyxNQUFNO0FBQ2xCO0FBQ0EsY0FBTVcsU0FBUyxHQUFHLElBQUlDLGtCQUFKLENBQ2hCbkMsTUFEZ0IsRUFFaEIsa0JBQU9BLE1BQVAsQ0FGZ0IsRUFHaEIsZUFIZ0IsRUFJaEJpQyxXQUpnQixDQUFsQjtBQU1BLGVBQU9DLFNBQVMsQ0FBQ0UsY0FBVixHQUEyQkMsSUFBM0IsQ0FBZ0MsTUFBTTtBQUMzQyxnQkFBTUMsS0FBSyxHQUFHLElBQUlDLGtCQUFKLENBQ1p2QyxNQURZLEVBRVosa0JBQU9BLE1BQVAsQ0FGWSxFQUdaLGVBSFksRUFJWmtDLFNBQVMsQ0FBQ00sU0FKRSxFQUtaWixVQUxZLENBQWQ7QUFPQVUsVUFBQUEsS0FBSyxDQUFDRyxVQUFOLENBQWlCQyxJQUFqQixHQUF3QixJQUF4QjtBQUNBLGlCQUFPSixLQUFLLENBQUNLLE9BQU4sRUFBUDtBQUNELFNBVk0sQ0FBUDtBQVdELE9BbkJEO0FBb0JEOztBQUNELFVBQU1DLFVBQVUsR0FBRyxzQ0FBa0I1QyxNQUFsQixDQUFuQjtBQUNBLFdBQU93QixPQUFPLENBQUNDLE9BQVIsR0FDSlksSUFESSxDQUNDLE1BQU07QUFDVixhQUFPTyxVQUFVLENBQUNDLFVBQVgsQ0FBc0IvQyxJQUF0QixFQUE0QkMsS0FBNUIsQ0FBUDtBQUNELEtBSEksRUFJSnNDLElBSkksQ0FJQyxNQUFNO0FBQ1ZuQyxNQUFBQSxpQkFBaUIsQ0FBQzBDLFVBQVUsQ0FBQ0UsUUFBWixDQUFqQjtBQUNBLGFBQU92QixXQUFXLEdBQUd3QixLQUFkLENBQW9CQyxHQUFHLElBQUk7QUFDaEM7QUFDQSxZQUFJaEQsTUFBTSxDQUFDaUQsc0JBQVgsRUFBbUMsTUFBTUQsR0FBTjs7QUFDbkNFLHVCQUFPQyxJQUFQLENBQ0csc0RBQXFEUCxVQUFVLENBQUNFLFFBQVMsRUFENUU7O0FBR0FJLHVCQUFPQyxJQUFQLENBQ0dILEdBQUcsSUFBSUEsR0FBRyxDQUFDSSxLQUFYLElBQW9CSixHQUFHLENBQUNJLEtBQUosQ0FBVUMsUUFBVixFQUFyQixJQUNHTCxHQUFHLElBQUlBLEdBQUcsQ0FBQ00sT0FEZCxJQUVFTixHQUFHLENBQUNLLFFBQUosRUFISjs7QUFLQSxlQUFPN0IsT0FBTyxDQUFDQyxPQUFSLEVBQVA7QUFDRCxPQVpNLENBQVA7QUFhRCxLQW5CSSxFQW9CSlksSUFwQkksQ0FvQkMsTUFBTTtBQUNWO0FBQ0EsVUFBSXZDLElBQUksQ0FBQ3lELFdBQVQsRUFBc0I7QUFDcEIsY0FBTUMsVUFBVSxHQUFHMUQsSUFBSSxDQUFDeUQsV0FBeEI7QUFFQSxZQUFJRSxjQUFjLEdBQUc7QUFDbkJDLFVBQUFBLFFBQVEsRUFBRTtBQUFFQyxZQUFBQSxNQUFNLEVBQUUsTUFBVjtBQUFrQkMsWUFBQUEsR0FBRyxFQUFFLElBQUl4RCxJQUFKLEdBQVd5RCxXQUFYO0FBQXZCLFdBRFM7QUFFbkJDLFVBQUFBLFNBQVMsRUFBRTtBQUFFaEMsWUFBQUEsSUFBSSxFQUFFLFdBQVI7QUFBcUJDLFlBQUFBLE1BQU0sRUFBRTtBQUE3QjtBQUZRLFNBQXJCO0FBSUEsY0FBTU8sS0FBSyxHQUFHLElBQUlDLGtCQUFKLENBQ1p2QyxNQURZLEVBRVosa0JBQU9BLE1BQVAsQ0FGWSxFQUdaLFdBSFksRUFJWjtBQUFFOEMsVUFBQUEsUUFBUSxFQUFFVTtBQUFaLFNBSlksRUFLWkMsY0FMWSxDQUFkO0FBT0FuQixRQUFBQSxLQUFLLENBQUNLLE9BQU47QUFDRCxPQWpCUyxDQWtCVjs7O0FBQ0EsYUFBT25CLE9BQU8sQ0FBQ0MsT0FBUixFQUFQO0FBQ0QsS0F4Q0ksRUF5Q0pZLElBekNJLENBeUNDLE1BQU07QUFDVixVQUNFeEIsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNsQixJQUFyQyxFQUEyQyxXQUEzQyxLQUNBRSxNQUFNLENBQUMrRCx1QkFGVCxFQUdFO0FBQ0EsZUFBT3ZDLE9BQU8sQ0FBQ0MsT0FBUixFQUFQO0FBQ0Q7O0FBQ0QsYUFBT3pCLE1BQU0sQ0FBQ2dFLG1CQUFQLENBQTJCQyxPQUEzQixDQUNMbkUsSUFESyxFQUVMQyxLQUZLLEVBR0xDLE1BSEssRUFJTEMsSUFKSyxFQUtMMkMsVUFMSyxDQUFQO0FBT0QsS0F2REksRUF3REpHLEtBeERJLENBd0RFQyxHQUFHLElBQUk7QUFDWixhQUFPSixVQUFVLENBQUNzQixJQUFYLENBQWdCbEIsR0FBaEIsRUFBcUJYLElBQXJCLENBQTBCLE1BQU07QUFDckMsY0FBTVcsR0FBTjtBQUNELE9BRk0sQ0FBUDtBQUdELEtBNURJLENBQVA7QUE2REQ7QUFFRDs7Ozs7OztBQUtBLFNBQU90QyxpQkFBUCxDQUF5QlosSUFBSSxHQUFHLEVBQWhDLEVBQW9DO0FBQ2xDLFFBQUlxRSxpQkFBaUIsR0FBR3RELE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NDLElBQWhDLENBQ3RCbEIsSUFEc0IsRUFFdEIsaUJBRnNCLENBQXhCOztBQUlBLFFBQUksQ0FBQ3FFLGlCQUFMLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBQ0QsUUFBSUMsbUJBQW1CLEdBQUd0RSxJQUFJLENBQUMsaUJBQUQsQ0FBOUI7QUFDQSxRQUFJdUUsY0FBSjs7QUFDQSxRQUFJLE9BQU9ELG1CQUFQLEtBQStCLFFBQW5DLEVBQTZDO0FBQzNDQyxNQUFBQSxjQUFjLEdBQUcsSUFBSWpFLElBQUosQ0FBU2dFLG1CQUFtQixHQUFHLElBQS9CLENBQWpCO0FBQ0QsS0FGRCxNQUVPLElBQUksT0FBT0EsbUJBQVAsS0FBK0IsUUFBbkMsRUFBNkM7QUFDbERDLE1BQUFBLGNBQWMsR0FBRyxJQUFJakUsSUFBSixDQUFTZ0UsbUJBQVQsQ0FBakI7QUFDRCxLQUZNLE1BRUE7QUFDTCxZQUFNLElBQUk5RCxZQUFNQyxLQUFWLENBQ0pELFlBQU1DLEtBQU4sQ0FBWUMsa0JBRFIsRUFFSlYsSUFBSSxDQUFDLGlCQUFELENBQUosR0FBMEIscUJBRnRCLENBQU47QUFJRCxLQW5CaUMsQ0FvQmxDOzs7QUFDQSxRQUFJLENBQUN3RSxRQUFRLENBQUNELGNBQUQsQ0FBYixFQUErQjtBQUM3QixZQUFNLElBQUkvRCxZQUFNQyxLQUFWLENBQ0pELFlBQU1DLEtBQU4sQ0FBWUMsa0JBRFIsRUFFSlYsSUFBSSxDQUFDLGlCQUFELENBQUosR0FBMEIscUJBRnRCLENBQU47QUFJRDs7QUFDRCxXQUFPdUUsY0FBYyxDQUFDbkQsT0FBZixFQUFQO0FBQ0Q7O0FBRUQsU0FBT04scUJBQVAsQ0FBNkJkLElBQUksR0FBRyxFQUFwQyxFQUF3QztBQUN0QyxVQUFNeUUscUJBQXFCLEdBQUcxRCxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUM1QmxCLElBRDRCLEVBRTVCLHFCQUY0QixDQUE5Qjs7QUFJQSxRQUFJLENBQUN5RSxxQkFBTCxFQUE0QjtBQUMxQjtBQUNEOztBQUVELFFBQUlDLHVCQUF1QixHQUFHMUUsSUFBSSxDQUFDLHFCQUFELENBQWxDOztBQUNBLFFBQ0UsT0FBTzBFLHVCQUFQLEtBQW1DLFFBQW5DLElBQ0FBLHVCQUF1QixJQUFJLENBRjdCLEVBR0U7QUFDQSxZQUFNLElBQUlsRSxZQUFNQyxLQUFWLENBQ0pELFlBQU1DLEtBQU4sQ0FBWUMsa0JBRFIsRUFFSCxxREFGRyxDQUFOO0FBSUQ7O0FBQ0QsV0FBT2dFLHVCQUFQO0FBQ0Q7QUFFRDs7Ozs7OztBQUtBLFNBQU9wRCxXQUFQLENBQW1CdEIsSUFBSSxHQUFHLEVBQTFCLEVBQThCO0FBQzVCLFFBQUkyRSxXQUFXLEdBQUc1RCxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ2xCLElBQXJDLEVBQTJDLFdBQTNDLENBQWxCOztBQUNBLFFBQUksQ0FBQzJFLFdBQUwsRUFBa0I7QUFDaEI7QUFDRDs7QUFDRCxRQUFJQyxhQUFhLEdBQUc1RSxJQUFJLENBQUMsV0FBRCxDQUF4QjtBQUNBLFFBQUl1QixJQUFKO0FBQ0EsUUFBSXNELFdBQVcsR0FBRyxJQUFsQjs7QUFFQSxRQUFJLE9BQU9ELGFBQVAsS0FBeUIsUUFBN0IsRUFBdUM7QUFDckNyRCxNQUFBQSxJQUFJLEdBQUcsSUFBSWpCLElBQUosQ0FBU3NFLGFBQWEsR0FBRyxJQUF6QixDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUksT0FBT0EsYUFBUCxLQUF5QixRQUE3QixFQUF1QztBQUM1Q0MsTUFBQUEsV0FBVyxHQUFHLENBQUMvRSxjQUFjLENBQUNnRiw0QkFBZixDQUE0Q0YsYUFBNUMsQ0FBZjtBQUNBckQsTUFBQUEsSUFBSSxHQUFHLElBQUlqQixJQUFKLENBQVNzRSxhQUFULENBQVA7QUFDRCxLQUhNLE1BR0E7QUFDTCxZQUFNLElBQUlwRSxZQUFNQyxLQUFWLENBQ0pELFlBQU1DLEtBQU4sQ0FBWUMsa0JBRFIsRUFFSlYsSUFBSSxDQUFDLFdBQUQsQ0FBSixHQUFvQixxQkFGaEIsQ0FBTjtBQUlELEtBbkIyQixDQW9CNUI7OztBQUNBLFFBQUksQ0FBQ3dFLFFBQVEsQ0FBQ2pELElBQUQsQ0FBYixFQUFxQjtBQUNuQixZQUFNLElBQUlmLFlBQU1DLEtBQVYsQ0FDSkQsWUFBTUMsS0FBTixDQUFZQyxrQkFEUixFQUVKVixJQUFJLENBQUMsV0FBRCxDQUFKLEdBQW9CLHFCQUZoQixDQUFOO0FBSUQ7O0FBRUQsV0FBTztBQUNMdUIsTUFBQUEsSUFESztBQUVMc0QsTUFBQUE7QUFGSyxLQUFQO0FBSUQ7QUFFRDs7Ozs7OztBQUtBLFNBQU9DLDRCQUFQLENBQW9DRixhQUFwQyxFQUFvRTtBQUNsRSxVQUFNRyxhQUFhLEdBQUcsc0JBQXRCO0FBQ0EsV0FDRUgsYUFBYSxDQUFDSSxPQUFkLENBQXNCLEdBQXRCLE1BQStCSixhQUFhLENBQUNLLE1BQWQsR0FBdUIsQ0FBdEQsSUFBMkQ7QUFDM0RGLElBQUFBLGFBQWEsQ0FBQ0csSUFBZCxDQUFtQk4sYUFBbkIsQ0FGRixDQUZrRSxDQUsvRDtBQUNKO0FBRUQ7Ozs7Ozs7O0FBTUEsU0FBT3BELGNBQVAsQ0FBc0I7QUFDcEJELElBQUFBLElBRG9CO0FBRXBCc0QsSUFBQUE7QUFGb0IsR0FBdEIsRUFNRztBQUNELFFBQUlBLFdBQUosRUFBaUI7QUFDZjtBQUNBLFlBQU1NLFNBQVMsR0FBRzVELElBQUksQ0FBQ3dDLFdBQUwsRUFBbEI7QUFDQSxhQUFPb0IsU0FBUyxDQUFDQyxTQUFWLENBQW9CLENBQXBCLEVBQXVCRCxTQUFTLENBQUNILE9BQVYsQ0FBa0IsR0FBbEIsQ0FBdkIsQ0FBUDtBQUNEOztBQUNELFdBQU96RCxJQUFJLENBQUN3QyxXQUFMLEVBQVA7QUFDRDs7QUF2UnlCOzs7ZUEwUmJqRSxjIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2UgfSBmcm9tICdwYXJzZS9ub2RlJztcbmltcG9ydCBSZXN0UXVlcnkgZnJvbSAnLi4vUmVzdFF1ZXJ5JztcbmltcG9ydCBSZXN0V3JpdGUgZnJvbSAnLi4vUmVzdFdyaXRlJztcbmltcG9ydCB7IG1hc3RlciB9IGZyb20gJy4uL0F1dGgnO1xuaW1wb3J0IHsgcHVzaFN0YXR1c0hhbmRsZXIgfSBmcm9tICcuLi9TdGF0dXNIYW5kbGVyJztcbmltcG9ydCB7IGFwcGx5RGV2aWNlVG9rZW5FeGlzdHMgfSBmcm9tICcuLi9QdXNoL3V0aWxzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5cbmV4cG9ydCBjbGFzcyBQdXNoQ29udHJvbGxlciB7XG4gIHNlbmRQdXNoKFxuICAgIGJvZHkgPSB7fSxcbiAgICB3aGVyZSA9IHt9LFxuICAgIGNvbmZpZyxcbiAgICBhdXRoLFxuICAgIG9uUHVzaFN0YXR1c1NhdmVkID0gKCkgPT4ge30sXG4gICAgbm93ID0gbmV3IERhdGUoKVxuICApIHtcbiAgICBpZiAoIWNvbmZpZy5oYXNQdXNoU3VwcG9ydCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgICBQYXJzZS5FcnJvci5QVVNIX01JU0NPTkZJR1VSRUQsXG4gICAgICAgICdNaXNzaW5nIHB1c2ggY29uZmlndXJhdGlvbidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSB0aGUgZXhwaXJhdGlvbl90aW1lIGFuZCBwdXNoX3RpbWUgd2l0aCBhIHZhbGlkIFVuaXggZXBvY2ggbWlsbGlzZWNvbmRzIHRpbWVcbiAgICBib2R5LmV4cGlyYXRpb25fdGltZSA9IFB1c2hDb250cm9sbGVyLmdldEV4cGlyYXRpb25UaW1lKGJvZHkpO1xuICAgIGJvZHkuZXhwaXJhdGlvbl9pbnRlcnZhbCA9IFB1c2hDb250cm9sbGVyLmdldEV4cGlyYXRpb25JbnRlcnZhbChib2R5KTtcbiAgICBpZiAoYm9keS5leHBpcmF0aW9uX3RpbWUgJiYgYm9keS5leHBpcmF0aW9uX2ludGVydmFsKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLlBVU0hfTUlTQ09ORklHVVJFRCxcbiAgICAgICAgJ0JvdGggZXhwaXJhdGlvbl90aW1lIGFuZCBleHBpcmF0aW9uX2ludGVydmFsIGNhbm5vdCBiZSBzZXQnXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEltbWVkaWF0ZSBwdXNoXG4gICAgaWYgKFxuICAgICAgYm9keS5leHBpcmF0aW9uX2ludGVydmFsICYmXG4gICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGJvZHksICdwdXNoX3RpbWUnKVxuICAgICkge1xuICAgICAgY29uc3QgdHRsTXMgPSBib2R5LmV4cGlyYXRpb25faW50ZXJ2YWwgKiAxMDAwO1xuICAgICAgYm9keS5leHBpcmF0aW9uX3RpbWUgPSBuZXcgRGF0ZShub3cudmFsdWVPZigpICsgdHRsTXMpLnZhbHVlT2YoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwdXNoVGltZSA9IFB1c2hDb250cm9sbGVyLmdldFB1c2hUaW1lKGJvZHkpO1xuICAgIGlmIChwdXNoVGltZSAmJiBwdXNoVGltZS5kYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYm9keVsncHVzaF90aW1lJ10gPSBQdXNoQ29udHJvbGxlci5mb3JtYXRQdXNoVGltZShwdXNoVGltZSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSWYgdGhlIHJlcSBjYW4gcGFzcyB0aGUgY2hlY2tpbmcsIHdlIHJldHVybiBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmdcbiAgICAvLyBwdXNoZXMgdG8gYmUgc2VudC4gV2UgcHJvYmFibHkgY2hhbmdlIHRoaXMgYmVoYXZpb3VyIGluIHRoZSBmdXR1cmUuXG4gICAgbGV0IGJhZGdlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBpZiAoYm9keS5kYXRhICYmIGJvZHkuZGF0YS5iYWRnZSkge1xuICAgICAgY29uc3QgYmFkZ2UgPSBib2R5LmRhdGEuYmFkZ2U7XG4gICAgICBsZXQgcmVzdFVwZGF0ZSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBiYWRnZSA9PSAnc3RyaW5nJyAmJiBiYWRnZS50b0xvd2VyQ2FzZSgpID09PSAnaW5jcmVtZW50Jykge1xuICAgICAgICByZXN0VXBkYXRlID0geyBiYWRnZTogeyBfX29wOiAnSW5jcmVtZW50JywgYW1vdW50OiAxIH0gfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBiYWRnZSA9PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgYmFkZ2UuX19vcCA9PSAnc3RyaW5nJyAmJlxuICAgICAgICBiYWRnZS5fX29wLnRvTG93ZXJDYXNlKCkgPT0gJ2luY3JlbWVudCcgJiZcbiAgICAgICAgTnVtYmVyKGJhZGdlLmFtb3VudClcbiAgICAgICkge1xuICAgICAgICByZXN0VXBkYXRlID0geyBiYWRnZTogeyBfX29wOiAnSW5jcmVtZW50JywgYW1vdW50OiBiYWRnZS5hbW91bnQgfSB9O1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIoYmFkZ2UpKSB7XG4gICAgICAgIHJlc3RVcGRhdGUgPSB7IGJhZGdlOiBiYWRnZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHZhbHVlIGZvciBiYWRnZSwgZXhwZWN0ZWQgbnVtYmVyIG9yICdJbmNyZW1lbnQnIG9yIHtpbmNyZW1lbnQ6IG51bWJlcn1cIjtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yY2UgZmlsdGVyaW5nIG9uIG9ubHkgdmFsaWQgZGV2aWNlIHRva2Vuc1xuICAgICAgY29uc3QgdXBkYXRlV2hlcmUgPSBhcHBseURldmljZVRva2VuRXhpc3RzKHdoZXJlKTtcbiAgICAgIGJhZGdlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICAvLyBCdWlsZCBhIHJlYWwgUmVzdFF1ZXJ5IHNvIHdlIGNhbiB1c2UgaXQgaW4gUmVzdFdyaXRlXG4gICAgICAgIGNvbnN0IHJlc3RRdWVyeSA9IG5ldyBSZXN0UXVlcnkoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIG1hc3Rlcihjb25maWcpLFxuICAgICAgICAgICdfSW5zdGFsbGF0aW9uJyxcbiAgICAgICAgICB1cGRhdGVXaGVyZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdFF1ZXJ5LmJ1aWxkUmVzdFdoZXJlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgd3JpdGUgPSBuZXcgUmVzdFdyaXRlKFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgbWFzdGVyKGNvbmZpZyksXG4gICAgICAgICAgICAnX0luc3RhbGxhdGlvbicsXG4gICAgICAgICAgICByZXN0UXVlcnkucmVzdFdoZXJlLFxuICAgICAgICAgICAgcmVzdFVwZGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgd3JpdGUucnVuT3B0aW9ucy5tYW55ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gd3JpdGUuZXhlY3V0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHB1c2hTdGF0dXMgPSBwdXNoU3RhdHVzSGFuZGxlcihjb25maWcpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gcHVzaFN0YXR1cy5zZXRJbml0aWFsKGJvZHksIHdoZXJlKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIG9uUHVzaFN0YXR1c1NhdmVkKHB1c2hTdGF0dXMub2JqZWN0SWQpO1xuICAgICAgICByZXR1cm4gYmFkZ2VVcGRhdGUoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIC8vIGFkZCB0aGlzIHRvIGlnbm9yZSBiYWRnZSB1cGRhdGUgZXJyb3JzIGFzIGRlZmF1bHRcbiAgICAgICAgICBpZiAoY29uZmlnLnN0b3BPbkJhZGdlVXBkYXRlRXJyb3IpIHRocm93IGVycjtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIGBCYWRnZSB1cGRhdGUgZXJyb3Igd2lsbCBiZSBpZ25vcmVkIGZvciBwdXNoIHN0YXR1cyAke3B1c2hTdGF0dXMub2JqZWN0SWR9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAoZXJyICYmIGVyci5zdGFjayAmJiBlcnIuc3RhY2sudG9TdHJpbmcoKSkgfHxcbiAgICAgICAgICAgICAgKGVyciAmJiBlcnIubWVzc2FnZSkgfHxcbiAgICAgICAgICAgICAgZXJyLnRvU3RyaW5nKClcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBVcGRhdGUgYXVkaWVuY2UgbGFzdFVzZWQgYW5kIHRpbWVzVXNlZFxuICAgICAgICBpZiAoYm9keS5hdWRpZW5jZV9pZCkge1xuICAgICAgICAgIGNvbnN0IGF1ZGllbmNlSWQgPSBib2R5LmF1ZGllbmNlX2lkO1xuXG4gICAgICAgICAgdmFyIHVwZGF0ZUF1ZGllbmNlID0ge1xuICAgICAgICAgICAgbGFzdFVzZWQ6IHsgX190eXBlOiAnRGF0ZScsIGlzbzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0sXG4gICAgICAgICAgICB0aW1lc1VzZWQ6IHsgX19vcDogJ0luY3JlbWVudCcsIGFtb3VudDogMSB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgd3JpdGUgPSBuZXcgUmVzdFdyaXRlKFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgbWFzdGVyKGNvbmZpZyksXG4gICAgICAgICAgICAnX0F1ZGllbmNlJyxcbiAgICAgICAgICAgIHsgb2JqZWN0SWQ6IGF1ZGllbmNlSWQgfSxcbiAgICAgICAgICAgIHVwZGF0ZUF1ZGllbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICB3cml0ZS5leGVjdXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3Qgd2FpdCBmb3IgdGhlIGF1ZGllbmNlIHVwZGF0ZSBwcm9taXNlIHRvIHJlc29sdmUuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYm9keSwgJ3B1c2hfdGltZScpICYmXG4gICAgICAgICAgY29uZmlnLmhhc1B1c2hTY2hlZHVsZWRTdXBwb3J0XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLnB1c2hDb250cm9sbGVyUXVldWUuZW5xdWV1ZShcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHdoZXJlLFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBhdXRoLFxuICAgICAgICAgIHB1c2hTdGF0dXNcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgcmV0dXJuIHB1c2hTdGF0dXMuZmFpbChlcnIpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXhwaXJhdGlvbiB0aW1lIGZyb20gdGhlIHJlcXVlc3QgYm9keS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgQSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfHVuZGVmaW5lZH0gVGhlIGV4cGlyYXRpb24gdGltZSBpZiBpdCBleGlzdHMgaW4gdGhlIHJlcXVlc3RcbiAgICovXG4gIHN0YXRpYyBnZXRFeHBpcmF0aW9uVGltZShib2R5ID0ge30pIHtcbiAgICB2YXIgaGFzRXhwaXJhdGlvblRpbWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICBib2R5LFxuICAgICAgJ2V4cGlyYXRpb25fdGltZSdcbiAgICApO1xuICAgIGlmICghaGFzRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lUGFyYW0gPSBib2R5WydleHBpcmF0aW9uX3RpbWUnXTtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHR5cGVvZiBleHBpcmF0aW9uVGltZVBhcmFtID09PSAnbnVtYmVyJykge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXcgRGF0ZShleHBpcmF0aW9uVGltZVBhcmFtICogMTAwMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwaXJhdGlvblRpbWVQYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV3IERhdGUoZXhwaXJhdGlvblRpbWVQYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuUFVTSF9NSVNDT05GSUdVUkVELFxuICAgICAgICBib2R5WydleHBpcmF0aW9uX3RpbWUnXSArICcgaXMgbm90IHZhbGlkIHRpbWUuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZXhwaXJhdGlvblRpbWUgaXMgdmFsaWQgb3Igbm90LCBpZiBpdCBpcyBub3QgdmFsaWQsIGV4cGlyYXRpb25UaW1lIGlzIE5hTlxuICAgIGlmICghaXNGaW5pdGUoZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLlBVU0hfTUlTQ09ORklHVVJFRCxcbiAgICAgICAgYm9keVsnZXhwaXJhdGlvbl90aW1lJ10gKyAnIGlzIG5vdCB2YWxpZCB0aW1lLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBleHBpcmF0aW9uVGltZS52YWx1ZU9mKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RXhwaXJhdGlvbkludGVydmFsKGJvZHkgPSB7fSkge1xuICAgIGNvbnN0IGhhc0V4cGlyYXRpb25JbnRlcnZhbCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiAgICAgIGJvZHksXG4gICAgICAnZXhwaXJhdGlvbl9pbnRlcnZhbCdcbiAgICApO1xuICAgIGlmICghaGFzRXhwaXJhdGlvbkludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4cGlyYXRpb25JbnRlcnZhbFBhcmFtID0gYm9keVsnZXhwaXJhdGlvbl9pbnRlcnZhbCddO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBleHBpcmF0aW9uSW50ZXJ2YWxQYXJhbSAhPT0gJ251bWJlcicgfHxcbiAgICAgIGV4cGlyYXRpb25JbnRlcnZhbFBhcmFtIDw9IDBcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgUGFyc2UuRXJyb3IuUFVTSF9NSVNDT05GSUdVUkVELFxuICAgICAgICBgZXhwaXJhdGlvbl9pbnRlcnZhbCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGlyYXRpb25JbnRlcnZhbFBhcmFtO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwdXNoIHRpbWUgZnJvbSB0aGUgcmVxdWVzdCBib2R5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBBIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ8dW5kZWZpbmVkfSBUaGUgcHVzaCB0aW1lIGlmIGl0IGV4aXN0cyBpbiB0aGUgcmVxdWVzdFxuICAgKi9cbiAgc3RhdGljIGdldFB1c2hUaW1lKGJvZHkgPSB7fSkge1xuICAgIHZhciBoYXNQdXNoVGltZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChib2R5LCAncHVzaF90aW1lJyk7XG4gICAgaWYgKCFoYXNQdXNoVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHVzaFRpbWVQYXJhbSA9IGJvZHlbJ3B1c2hfdGltZSddO1xuICAgIHZhciBkYXRlO1xuICAgIHZhciBpc0xvY2FsVGltZSA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIHB1c2hUaW1lUGFyYW0gPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRlID0gbmV3IERhdGUocHVzaFRpbWVQYXJhbSAqIDEwMDApO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHB1c2hUaW1lUGFyYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpc0xvY2FsVGltZSA9ICFQdXNoQ29udHJvbGxlci5wdXNoVGltZUhhc1RpbWV6b25lQ29tcG9uZW50KHB1c2hUaW1lUGFyYW0pO1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKHB1c2hUaW1lUGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLlBVU0hfTUlTQ09ORklHVVJFRCxcbiAgICAgICAgYm9keVsncHVzaF90aW1lJ10gKyAnIGlzIG5vdCB2YWxpZCB0aW1lLidcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIENoZWNrIHB1c2hUaW1lIGlzIHZhbGlkIG9yIG5vdCwgaWYgaXQgaXMgbm90IHZhbGlkLCBwdXNoVGltZSBpcyBOYU5cbiAgICBpZiAoIWlzRmluaXRlKGRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLlBVU0hfTUlTQ09ORklHVVJFRCxcbiAgICAgICAgYm9keVsncHVzaF90aW1lJ10gKyAnIGlzIG5vdCB2YWxpZCB0aW1lLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGUsXG4gICAgICBpc0xvY2FsVGltZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIElTTzg2MDEgZm9ybWF0dGVkIGRhdGUgY29udGFpbnMgYSB0aW1lem9uZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHB1c2hUaW1lUGFyYW0ge3N0cmluZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgcHVzaFRpbWVIYXNUaW1lem9uZUNvbXBvbmVudChwdXNoVGltZVBhcmFtOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBvZmZzZXRQYXR0ZXJuID0gLyguKykoWystXSlcXGRcXGQ6XFxkXFxkJC87XG4gICAgcmV0dXJuIChcbiAgICAgIHB1c2hUaW1lUGFyYW0uaW5kZXhPZignWicpID09PSBwdXNoVGltZVBhcmFtLmxlbmd0aCAtIDEgfHwgLy8gMjAwNy0wNC0wNVQxMjozMFpcbiAgICAgIG9mZnNldFBhdHRlcm4udGVzdChwdXNoVGltZVBhcmFtKVxuICAgICk7IC8vIDIwMDctMDQtMDVUMTI6MzAuMDAwKzAyOjAwLCAyMDA3LTA0LTA1VDEyOjMwLjAwMC0wMjowMFxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgZGF0ZSB0byBJU08gZm9ybWF0IGluIFVUQyB0aW1lIGFuZCBzdHJpcHMgdGhlIHRpbWV6b25lIGlmIGBpc0xvY2FsVGltZWAgaXMgdHJ1ZVxuICAgKiBAcGFyYW0gZGF0ZSB7RGF0ZX1cbiAgICogQHBhcmFtIGlzTG9jYWxUaW1lIHtib29sZWFufVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGZvcm1hdFB1c2hUaW1lKHtcbiAgICBkYXRlLFxuICAgIGlzTG9jYWxUaW1lLFxuICB9OiB7XG4gICAgZGF0ZTogRGF0ZSxcbiAgICBpc0xvY2FsVGltZTogYm9vbGVhbixcbiAgfSkge1xuICAgIGlmIChpc0xvY2FsVGltZSkge1xuICAgICAgLy8gU3RyaXAgJ1onXG4gICAgICBjb25zdCBpc29TdHJpbmcgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICByZXR1cm4gaXNvU3RyaW5nLnN1YnN0cmluZygwLCBpc29TdHJpbmcuaW5kZXhPZignWicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQdXNoQ29udHJvbGxlcjtcbiJdfQ==